(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.iflow = {})));
}(this, (function (exports) { 'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};









var asyncToGenerator = function (fn) {
  return function () {
    var gen = fn.apply(this, arguments);
    return new Promise(function (resolve, reject) {
      function step(key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }

        if (info.done) {
          resolve(value);
        } else {
          return Promise.resolve(value).then(function (value) {
            step("next", value);
          }, function (err) {
            step("throw", err);
          });
        }
      }

      return step("next");
    });
  };
};

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();





var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};



var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};





var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();













var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

/* global toString */
var Observation = function () {
  /**
   * observersQueue -> broadcast
   * eventsQueue -> trigger
   * receiversQueue -> subscribe
   */
  function Observation() {
    classCallCheck(this, Observation);

    this._observersQueue = new Set();
    this._dispatchersQueue = new Set();
    this._receiversQueue = new Set();
    this._broadcast = new Set();
    this._subscribe = new Set();
    this._trigger = new Set();
  }

  /**
   *
   * @param model
   */


  createClass(Observation, [{
    key: 'watch',
    value: function watch(model) {
      var observer = this._observer.bind(this, model);
      this._observe(observer);
      this._observe(this._parentObserversQueue.bind(this));
      var dispatcher = this._dispatcher.bind(this, model);
      this._dispatch(dispatcher);
      this._dispatch(this._parentDispatchersQueue.bind(this));
      var receiver = this._receiver.bind(this, model);
      this._receive(receiver);
      this._receive(this._parentReceiversQueue.bind(this));
    }

    /**
     *
     * @param observer
     * @private
     */

  }, {
    key: '_observe',
    value: function _observe(observer) {
      this._observersQueue.add(observer);
    }

    /**
     *
     * @param dispatcher
     * @private
     */

  }, {
    key: '_dispatch',
    value: function _dispatch(dispatcher) {
      this._dispatchersQueue.add(dispatcher);
    }

    /**
     *
     * @param receiver
     * @private
     */

  }, {
    key: '_receive',
    value: function _receive(receiver) {
      this._receiversQueue.add(receiver);
    }

    /**
     *
     * @param args
     * @private
     */

  }, {
    key: '_observer',
    value: function _observer() {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      this._broadcast.forEach(function (notice) {
        return notice.apply(undefined, args);
      });
    }

    /**
     *
     * @param args
     * @private
     */

  }, {
    key: '_parentObserversQueue',
    value: function _parentObserversQueue() {
      this.parentObserversQueue && this.parentObserversQueue.apply(this, arguments);
    }

    /**
     *
     * @param args
     * @private
     */

  }, {
    key: '_dispatcher',
    value: function _dispatcher() {
      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return [].concat(toConsumableArray(this._subscribe)).reduce(function (prev, subscriber) {
        var isAsync = args.slice(-1)[0];
        if (typeof prev === 'undefined') {
          var result = subscriber.apply(undefined, toConsumableArray(args.slice(0, -1)));
          // separate async and sync dispatcher
          if (!isAsync && toString.call(result) === '[object Promise]' || isAsync && toString.call(result) !== '[object Promise]') {
            result = undefined;
          }
          return result;
        } else {
          var _result = subscriber.apply(undefined, toConsumableArray(args.slice(0, -2)).concat([prev]));
          // separate async and sync dispatcher
          if (!isAsync && toString.call(_result) === '[object Promise]' || isAsync && toString.call(_result) !== '[object Promise]') _result = prev;
          return _result || prev;
        }
      }, undefined);
    }

    /**
     *
     * @param args
     * @private
     */

  }, {
    key: '_parentDispatchersQueue',
    value: function _parentDispatchersQueue() {
      return this.parentDispatchersQueue ? this.parentDispatchersQueue.apply(this, arguments) : undefined;
    }

    /**
     *
     * @param args
     * @private
     */

  }, {
    key: '_receiver',
    value: function _receiver() {
      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      this._trigger.forEach(function (trigger) {
        return trigger.apply(undefined, args);
      });
    }

    /**
     *
     * @param args
     * @private
     */

  }, {
    key: '_parentReceiversQueue',
    value: function _parentReceiversQueue() {
      this.parentReceiversQueue && this.parentReceiversQueue.apply(this, arguments);
    }

    /**
     *
     * @param item
     * @param key
     */

  }, {
    key: 'handleSubObserversQueue',
    value: function handleSubObserversQueue(item, key) {
      var _this = this;

      var parentObserversQueue = function parentObserversQueue() {
        for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }

        return _this._observersQueue.forEach(function (observer) {
          return observer.apply(undefined, args);
        });
      };
      item.parentObserversQueue = parentObserversQueue.bind(Object.create(null), key);
    }

    /**
     *
     * @param item
     * @param key
     */

  }, {
    key: 'handleSubDispatchersQueue',
    value: function handleSubDispatchersQueue(item, key) {
      var _this2 = this;

      var parentDispatchersQueue = function parentDispatchersQueue() {
        for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
          args[_key5] = arguments[_key5];
        }

        return [].concat(toConsumableArray(_this2._dispatchersQueue)).reduce(function (prev, dispatcher) {
          return dispatcher.apply(undefined, args) || prev;
        }, undefined);
      };
      item.parentDispatchersQueue = parentDispatchersQueue.bind(Object.create(null), key);
    }

    /**
     *
     * @param item
     * @param key
     */

  }, {
    key: 'handleSubReceiversQueue',
    value: function handleSubReceiversQueue(item, key) {
      var _this3 = this;

      var parentReceiversQueue = function parentReceiversQueue() {
        for (var _len6 = arguments.length, args = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
          args[_key6] = arguments[_key6];
        }

        return _this3._receiversQueue.forEach(function (receiver) {
          return receiver.apply(undefined, args);
        });
      };
      item.parentReceiversQueue = parentReceiversQueue.bind(Object.create(null), key);
    }

    /**
     *
     * @param notice
     * @param isEarliest
     * @returns {Observation}
     */

  }, {
    key: 'addObserver',
    value: function addObserver(notice) {
      var isEarliest = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (typeof notice === 'function') {
        if (isEarliest) {
          this._broadcast = new Set([notice].concat(toConsumableArray(this._broadcast)));
        } else {
          this._broadcast.add(notice);
        }
      }
      return this;
    }

    /**
     *
     * @param notice
     * @returns {Observation}
     */

  }, {
    key: 'removeObserver',
    value: function removeObserver(notice) {
      if (typeof notice === 'function') this._broadcast.delete(notice);
      return this;
    }

    /**
     *
     * @param subscriber
     * @returns {Observation}
     */

  }, {
    key: 'addInterceptor',
    value: function addInterceptor(subscriber) {
      if (typeof subscriber === 'function') this._subscribe.add(subscriber);
      return this;
    }

    /**
     *
     * @param trigger
     * @returns {Observation}
     */

  }, {
    key: 'addListener',
    value: function addListener(trigger) {
      if (typeof trigger === 'function') this._trigger.add(trigger);
      return this;
    }

    /**
     *
     * @param subscriber
     * @returns {Observation}
     */

  }, {
    key: 'removeInterceptor',
    value: function removeInterceptor(subscriber) {
      if (typeof subscriber === 'function') this._subscribe.delete(subscriber);
      return this;
    }

    /**
     *
     * @param trigger
     * @returns {Observation}
     */

  }, {
    key: 'removeListener',
    value: function removeListener(trigger) {
      if (typeof trigger === 'function') this._trigger.delete(trigger);
      return this;
    }
  }]);
  return Observation;
}();

/* global toString */

var Middleware = function () {
  /**
   *
   * @param pipe
   */
  function Middleware(pipe) {
    classCallCheck(this, Middleware);

    this._middlewareQueue = new Set();
    this._middleware = new Set();
    this._applyMiddleware(pipe);
  }

  /**
   *
   * @param pipe
   * @private
   */


  createClass(Middleware, [{
    key: '_applyMiddleware',
    value: function _applyMiddleware(pipe) {
      pipe._middleware = this._middleware;
      pipe._middlewareQueue = this._middlewareQueue;
      pipe.handleSubMiddlewareQueue = this.handleSubMiddlewareQueue.bind(pipe);
      var parentMiddlewareQueue = this._parentMiddlewareQueue.bind(pipe);
      var runMiddleware = this._runMiddleware.bind(pipe);
      this._addMiddleware([parentMiddlewareQueue, runMiddleware]);
    }

    /**
     *
     * @param args
     * @returns {undefined}
     * @private
     */

  }, {
    key: '_parentMiddlewareQueue',
    value: function _parentMiddlewareQueue() {
      return this.parentMiddlewareQueue ? this.parentMiddlewareQueue.apply(this, arguments) : undefined;
    }

    /**
     *
     * @param args
     * @returns {*}
     * @private
     */

  }, {
    key: '_runMiddleware',
    value: function _runMiddleware() {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return [].concat(toConsumableArray(this._middleware)).reduce(function (prev, middleware) {
        // if middleware reduce cover prev value it could use `middleware(...args) || prev`
        if (typeof prev === 'undefined') {
          return middleware.apply(undefined, args);
        } else {
          return middleware.apply(undefined, toConsumableArray(args.slice(0, -1)).concat([prev])) || prev;
        }
      }, undefined);
    }

    /**
     *
     * @param middleware
     * @private
     */

  }, {
    key: '_addMiddleware',
    value: function _addMiddleware(middleware) {
      if (toString.call(middleware) === '[object Array]') {
        middleware.forEach(this._addMiddleware.bind(this));
      }
      if (typeof middleware === 'function') {
        this._middlewareQueue.add(middleware);
      }
    }

    /**
     *
     * @param item
     * @param key
     */

  }, {
    key: 'handleSubMiddlewareQueue',
    value: function handleSubMiddlewareQueue(item, key) {
      var _this = this;

      var parentMiddlewareQueue = function parentMiddlewareQueue() {
        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        return [].concat(toConsumableArray(_this._middlewareQueue)).reduce(function (prev, middleware) {
          return middleware.apply(undefined, args) || prev;
        }, undefined);
      };
      item.parentMiddlewareQueue = parentMiddlewareQueue.bind(Object.create(null), key);
    }

    /**
     *
     * @param middleware
     */

  }, {
    key: 'addMiddleware',
    value: function addMiddleware(middleware) {
      if (toString.call(middleware) === '[object Array]') {
        middleware.forEach(this.addMiddleware.bind(this));
      }
      if (typeof middleware === 'function') {
        this._middleware.add(middleware.bind(Object.create(null), this._model));
      }
      return this;
    }
  }]);
  return Middleware;
}();

var ErrorType = {
  DuplicateCreate: "The Model have been created, and recheck it 'create' API invoke config.",
  MiddlewareInvalid: "The Middleware is invalid, and recheck it 'middleware' API invoke config."
};

/* global toString */

var unProxyTypes = ['[object Set]', '[object WeakSet]', '[object Map]', '[object WeakMap]'];

var isUnproxy = (function (target) {
  return unProxyTypes.includes(toString.call(target));
});

/* global toString */
var INFINITY = 1 / 0;

var isSymbol = function isSymbol(value) {
  var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
  return type === 'symbol' || type === 'object' && value !== null && toString.call(value) === '[object Symbol]';
};

var toKey = function toKey(value) {
  if (typeof value === 'string' || isSymbol(value)) {
    return value;
  }
  var result = '' + value;
  return result === '0' && 1 / value === -INFINITY ? '-0' : result;
};

var get$1 = function get$$1(object, path) {
  if (typeof path === 'string') path = [path];
  var index = 0;
  var length = path.length;
  while (object !== null && index < length) {
    object = object[toKey(path[index++])];
  }
  return index && index === length ? object : undefined;
};

/* global toString */

//TODO separate update config
var update = {
  isForce: false
};

var Pipe = function (_Observation) {
  inherits(Pipe, _Observation);

  /**
   *
   * iFlow's Pipe Model build on observer mode
   * data flow:
   *
   *      action -> middleware -> reflector -> observer
   *        |                                       |
   *      store <------------ iFlow ------------- state
   *
   * @param originalModel
   * @param autoInitialize
   * @returns {*}
   */
  function Pipe(originalModel) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$autoInitialize = _ref.autoInitialize,
        autoInitialize = _ref$autoInitialize === undefined ? false : _ref$autoInitialize;

    classCallCheck(this, Pipe);

    var _this = possibleConstructorReturn(this, (Pipe.__proto__ || Object.getPrototypeOf(Pipe)).call(this, originalModel));

    _this._originalModel = originalModel;
    _this._isInitialized = false;
    _this._update = update;
    _this._initialValues = new Set();
    _this._model = isUnproxy(originalModel) ? originalModel : new Proxy(originalModel, {
      set: _this._setterProxy.bind(_this),
      deleteProperty: _this._deleteProperty.bind(_this)
    });
    _this.addMiddleware = new Middleware(_this).addMiddleware.bind(_this);
    _this._setup(_this._model);
    // root pipe
    var isSettable = !isUnproxy(_this._model) && !_this._model['__pipe__'] && Object.isExtensible(_this._model);
    isSettable && Reflect.defineProperty(_this._model, '__pipe__', {
      value: _this,
      configurable: false,
      enumerable: false,
      writable: false
    });
    if (autoInitialize) {
      var _ret;

      _this._isInitialized = true;
      return _ret = _this._model, possibleConstructorReturn(_this, _ret);
    }
    return _this;
  }

  /**
   * Activate watchers use observers queue.
   * Action functions is inserted extra actions.
   * @param model
   * @private
   */


  createClass(Pipe, [{
    key: '_setup',
    value: function _setup(model) {
      this.watch(model);
      this._insertActionsInjector(model);
    }

    /**
     * Actions respectively inserted
     * @param model
     * @private
     */

  }, {
    key: '_insertActionsInjector',
    value: function _insertActionsInjector(model) {
      this._setActions(model);
      if (toString.call(model) === '[object Object]') {
        this._setProtoActions(model);
      }
    }

    /**
     * Plain actions setters
     * @param model
     * @private
     */

  }, {
    key: '_setActions',
    value: function _setActions(model) {
      var _this2 = this;

      Reflect.ownKeys(model).forEach(function (key) {
        var descriptor = Reflect.getOwnPropertyDescriptor(model, key);
        var property = _this2._rebindAction(descriptor, model, key);
        Reflect.defineProperty(model, key, property);
      });
    }

    /**
     * Check pipe model instantiable type
     * @param item
     * @returns {boolean}
     */

  }, {
    key: '_setProtoActions',


    /**
     * Current model's proto reset descriptor
     * @param model
     * @private
     */
    value: function _setProtoActions(model) {
      var _this3 = this;

      Reflect.ownKeys(model.__proto__).forEach(function (key) {
        if (!Reflect.ownKeys({}.__proto__).includes(key)) {
          var descriptor = Reflect.getOwnPropertyDescriptor(model.__proto__, key);
          var property = _extends({}, _this3._rebindAction(descriptor, model, key), {
            enumerable: true
          });
          Reflect.defineProperty(model, key, property);
        }
      });
    }

    /**
     * Register sub Pipe actions transmitter
     * @param item
     * @param key
     * @private
     */

  }, {
    key: '_handleSubPipe',
    value: function _handleSubPipe(item, key) {
      this._handleParentNode(item);
      this.handleSubObserversQueue(item, key);
      this.handleSubDispatchersQueue(item, key);
      this.handleSubReceiversQueue(item, key);
      this.handleSubMiddlewareQueue(item, key);
    }

    /**
     * Inject parent node
     * @param item
     * @private
     */

  }, {
    key: '_handleParentNode',
    value: function _handleParentNode(item) {
      var isSettable = !isUnproxy(item._model) && item._model && !item._model.__parentPipe__ && Object.isExtensible(item._model);
      isSettable && Reflect.defineProperty(item._model, '__parentPipe__', {
        value: this,
        configurable: false,
        enumerable: false,
        writable: false
      });
    }

    /**
     * Check return pipe model instance
     * @param item
     * @returns {boolean}
     * @private
     */

  }, {
    key: '_rebindModelAction',


    /**
     * Bind plain actions hook
     * @param model
     * @param item
     * @param key
     * @returns {function(...[*])}
     * @private
     */
    value: function _rebindModelAction(model, item, key) {
      var _this4 = this;

      return function () {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        var fn = item.bind.apply(item, [model].concat(args, [model]));
        return _this4._handleTypeFunc(fn, [_this4.beforeActionHook.bind(_this4, key, model, args), _this4.afterActionHook.bind(_this4, key, model)], [item, model]);
      };
    }

    /**
     * Bind actions hook
     * @param descriptor
     * @param model
     * @param key
     * @returns {*}
     * @private
     */

  }, {
    key: '_rebindAction',
    value: function _rebindAction(descriptor, model, key) {
      var _this5 = this;

      //TODO ['value', 'get', 'set']?
      var descriptorFields = ['value', 'set'];
      return descriptorFields.reduce(function (descriptor, field) {
        // skip __pipe__ or __parentPipe__ property
        if (['__pipe__', '__parentPipe__'].includes(key)) return descriptor;
        if (descriptor[field] && typeof descriptor[field] === 'function') {
          var fn = function fn() {
            var _descriptor$field;

            for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2];
            }

            var fn = (_descriptor$field = descriptor[field]).bind.apply(_descriptor$field, [model].concat(args, [model]));
            return _this5._handleTypeFunc(fn, [_this5.beforeActionHook.bind(_this5, key, model, args), _this5.afterActionHook.bind(_this5, key, model)], [descriptor[field], model, field]);
          };
          return _extends({}, descriptor, defineProperty({}, field, fn));
        } else if (field === 'value' && descriptor.value && _typeof(descriptor.value) === 'object') {
          var item = descriptor.value;
          var value = item;
          if (item.constructor === Pipe) {
            if (!item._model.__parentPipe__) {
              _this5._handleSubPipe(item, key);
              value = item.create();
            } else {
              var pipe = new Pipe(item._model);
              _this5._handleSubPipe(pipe, key);
              value = pipe.create();
              var parent = item._model.__parentPipe__._model;
              Reflect.ownKeys(parent).forEach(function (key) {
                if (parent[key] === item._originalModel) {
                  Reflect.defineProperty(parent, key, _extends({}, Reflect.getOwnPropertyDescriptor(parent, key), {
                    value: value
                  }));
                }
              });
            }
          } else if (Pipe._isInstance(item)) {
            if (!item.__parentPipe__) {
              _this5._handleSubPipe(item.__pipe__, key);
            } else {
              var _pipe = new Pipe(item);
              _this5._handleSubPipe(_pipe, key);
              value = _pipe.create();
              var _parent = item.__parentPipe__._model;
              Reflect.ownKeys(_parent).forEach(function (key) {
                if (_parent[key] === item) {
                  Reflect.defineProperty(_parent, key, _extends({}, Reflect.getOwnPropertyDescriptor(_parent, key), {
                    value: value
                  }));
                }
              });
            }
          } else if (Pipe._isInstantiable(item)) {
            value = new Pipe(item, { autoInitialize: true });
            _this5._handleSubPipe(value['__pipe__'], key);
          }
          return _extends({}, descriptor, {
            value: value
          });
        } else {
          return descriptor;
        }
      }, descriptor);
    }

    /**
     * The core proxy states setter
     * @param target
     * @param key
     * @param value
     * @param receiver
     * @returns {boolean}
     * @private
     */

  }, {
    key: '_setterProxy',
    value: function _setterProxy(target, key, value, receiver) {
      var assignment = this._applyHookBeforeReflector(value, key, { mode: 'set' });
      // TODO force setter ?
      // if (assignment === target[key]) return true
      var result = Reflect.set(target, key, assignment, receiver);
      this._applyHookAfterReflector(assignment, key, { mode: 'set' });
      return result;
    }

    /**
     * The core proxy states deleter
     * @param target
     * @param key
     * @returns {boolean}
     * @private
     */

  }, {
    key: '_deleteProperty',
    value: function _deleteProperty(target, key) {
      this._applyHookBeforeReflector(target[key], key, { mode: 'delete' });
      var deletePropertyResult = Reflect.deleteProperty(target, key);
      this._applyHookAfterReflector(target[key], key, { mode: 'delete' });
      return deletePropertyResult;
    }

    /**
     * Handle hook before state change value
     * @param value
     * @param key
     * @param params
     * @returns {*}
     * @private
     */

  }, {
    key: '_applyHookBeforeReflector',
    value: function _applyHookBeforeReflector(value, key, params) {
      var assignment = value;
      var isSkipHook = this._isSkipHook(key);
      if (isSkipHook) {
        return assignment;
      }
      if (typeof value === 'function' && params.mode === 'set') {
        assignment = this._rebindModelAction(this._model, value, key);
      }
      if (typeof value !== 'function' && this._isInitialized && this._update.isForce && this._update.isForce) {
        assignment = [].concat(toConsumableArray(this._middlewareQueue)).reduce(function (assignment, middleware) {
          var evaluation = middleware(key, assignment, params);
          var isValid = typeof evaluation !== 'undefined';
          return isValid ? evaluation : assignment;
        }, assignment);
      }
      // Insert dynamic state
      if ((typeof assignment === 'undefined' ? 'undefined' : _typeof(assignment)) === 'object' && params.mode === 'set') {
        var dynamicState = new Pipe(assignment);
        assignment = dynamicState.create();
        this._handleSubPipe(dynamicState, key);
      }
      return assignment;
    }

    /**
     * Handle hook after state change value
     * @param args
     * @returns {null}
     * @private
     */

  }, {
    key: '_applyHookAfterReflector',
    value: function _applyHookAfterReflector() {
      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      var assignment = args[0];
      var keys = args.slice(1, -1);
      var params = args.slice(-1)[0];
      // TODO process batch isSkipHook
      var isSkipHook = this._isSkipHook(keys[0]);
      if (isSkipHook) {
        return null;
      }
      if (typeof assignment !== 'function' && this._isInitialized && this._update.isForce && this._update.isForce) {
        this._observersQueue.forEach(function (observer) {
          return observer.apply(undefined, toConsumableArray(keys).concat([assignment, params]));
        });
      }
    }

    /**
     * Check to return is-skip hook
     * Non primitive data types skip hook
     * @param key
     * @returns {boolean}
     * @private
     */

  }, {
    key: '_isSkipHook',
    value: function _isSkipHook(key) {
      // TODO remove it?
      // const isChangeArrayLength = key === 'length' && toString.call(this._model) === '[object Array]'
      return !this._isInitialized || !this._update.isForce // || isChangeArrayLength
      ;
    }

    /**
     * Handle before action hook
     * @param key
     * @param model
     * @param args
     * @param async
     * @returns {*}
     */

  }, {
    key: 'beforeActionHook',
    value: function beforeActionHook(key, model, args) {
      var _ref2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},
          async = _ref2.async;

      if (this._isInitialized && this._update.isForce) {
        var result = args;

        var _arr = [].concat(toConsumableArray(this._dispatchersQueue));

        for (var _i = 0; _i < _arr.length; _i++) {
          var dispatcher = _arr[_i];
          if (async) {
            var dispatcherResult = dispatcher(key, model, result, async);
            if (dispatcherResult) result = dispatcherResult;
          } else {
            var _dispatcherResult = dispatcher(key, model, result, async);
            if (_dispatcherResult && Array.isArray(_dispatcherResult) && !_dispatcherResult.some(function (i) {
              return toString.call(i) === '[object Promise]';
            })) result = _dispatcherResult;
          }
        }
        if (result !== args) {
          return result;
        }
      }
    }

    /**
     * Handle after action hook
     * @param key
     * @param model
     * @returns {Promise.<void>}
     */

  }, {
    key: 'afterActionHook',
    value: function afterActionHook(key, model) {
      if (this._isInitialized && this._update.isForce) {
        var _arr2 = [].concat(toConsumableArray(this._receiversQueue));

        for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
          var receiver = _arr2[_i2];
          receiver(key, model);
        }
      }
    }

    /**
     * Handle actions with actions hook
     * @param fn
     * @param beforeHook
     * @param afterHook
     * @param item
     * @param model
     * @returns {*}
     * @private
     */

  }, {
    key: '_handleTypeFunc',
    value: function _handleTypeFunc(fn, _ref3) {
      var _this6 = this;

      var _ref6 = slicedToArray(_ref3, 2),
          beforeHook = _ref6[0],
          afterHook = _ref6[1];

      var _ref4 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [],
          _ref5 = slicedToArray(_ref4, 2),
          item = _ref5[0],
          model = _ref5[1];

      if (toString.call(fn) === '[object AsyncFunction]' || fn.name === 'bound __async__' || fn.name === 'bound ' && fn.__proto__.name === ''
      // When use strict, arguments.callee can not be accessed, so bound function name is empty string ''.
      ) {
          return asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
            var beforeHookResult, result;
            return regeneratorRuntime.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    _context3.next = 2;
                    return asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
                      return regeneratorRuntime.wrap(function _callee$(_context) {
                        while (1) {
                          switch (_context.prev = _context.next) {
                            case 0:
                              return _context.abrupt('return', beforeHook({ async: true }));

                            case 1:
                            case 'end':
                              return _context.stop();
                          }
                        }
                      }, _callee, _this6);
                    }))();

                  case 2:
                    beforeHookResult = _context3.sent;

                    if (typeof beforeHookResult !== 'undefined') {
                      if (!Array.isArray(beforeHookResult)) beforeHookResult = [beforeHookResult];
                      fn = item.bind.apply(item, [model].concat(toConsumableArray(beforeHookResult), [model]));
                    }
                    _context3.next = 6;
                    return fn();

                  case 6:
                    result = _context3.sent;
                    _context3.next = 9;
                    return asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
                      return regeneratorRuntime.wrap(function _callee2$(_context2) {
                        while (1) {
                          switch (_context2.prev = _context2.next) {
                            case 0:
                              return _context2.abrupt('return', afterHook());

                            case 1:
                            case 'end':
                              return _context2.stop();
                          }
                        }
                      }, _callee2, _this6);
                    }))();

                  case 9:
                    return _context3.abrupt('return', result);

                  case 10:
                  case 'end':
                    return _context3.stop();
                }
              }
            }, _callee3, _this6);
          }))();
        }
      var beforeHookResult = beforeHook({ async: false });
      // if beforeHookResult is exist, it will replace the action parameters
      if (typeof beforeHookResult !== 'undefined') {
        if (!Array.isArray(beforeHookResult)) beforeHookResult = [beforeHookResult];
        fn = item.bind.apply(item, [model].concat(toConsumableArray(beforeHookResult), [model]));
      }
      var result = fn();
      afterHook();
      return result;
    }

    /**
     * Traverse initialValue's functions and reduce to get the initial values
     * @param initial
     * @returns {*}
     * @private
     */

  }, {
    key: '_getInitialValues',
    value: function _getInitialValues(initial) {
      return [].concat(toConsumableArray(this._initialValues)).reduce(function (prev, getInitialValue) {
        var initialValue = getInitialValue(prev);
        return typeof initialValue !== 'undefined' ? initialValue : prev;
      }, initial);
    }

    /**
     * Assign initial values to pipe model
     * @param item
     * @param key
     * @private
     */

  }, {
    key: '_assign',
    value: function _assign(item, key) {
      var descriptor = Object.getOwnPropertyDescriptor(this._model, key);
      var isPrimitiveTypes = !descriptor || !['function', 'object'].includes(_typeof(descriptor.value));
      var isExistValue = descriptor && typeof descriptor.value !== 'undefined';
      if (isPrimitiveTypes) {
        if (!isExistValue && Pipe._isInstantiable(item)) {
          var pipe = new Pipe(item);
          this._handleSubPipe(pipe, key);
          this._model[key] = pipe.create();
        } else {
          this._model[key] = item;
        }
      } else if (isExistValue && Pipe._isInstance(descriptor.value)) {
        this._model[key] = this._model[key]['__pipe__'].create(item);
      }
    }

    /**
     * Set Initial function for getting initial value
     * @param getInitial
     * @returns {Pipe}
     */

  }, {
    key: 'setInitializeValue',
    value: function setInitializeValue(getInitial) {
      if (typeof getInitial === 'function') this._initialValues.add(getInitial);
      return this;
    }

    /**
     * Overall middleware control the Pipe store
     * @param middleware
     * @returns {Pipe}
     */

  }, {
    key: 'middleware',
    value: function middleware() {
      var _this7 = this;

      for (var _len4 = arguments.length, _middleware = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        _middleware[_key4] = arguments[_key4];
      }

      _middleware.forEach(function (wares) {
        if (typeof wares === 'function') {
          _this7.addMiddleware(wares);
        } else if (toString.call(wares) === '[object Object]') {
          Object.entries(wares).forEach(function (_ref10) {
            var _ref11 = slicedToArray(_ref10, 2),
                key = _ref11[0],
                ware = _ref11[1];

            switch (key) {
              case 'stateWillInitialize':
                return _this7.setInitializeValue(ware);
              case 'actionWillStart':
                return _this7.addInterceptor(ware); // support async
              case 'stateWillChange':
                return _this7.addMiddleware(ware);
              case 'stateDidChange':
                return _this7.addObserver(ware);
              case 'actionDidEnd':
                return _this7.addListener(ware); // support async
              default:
                throw new Error(ErrorType.MiddlewareInvalid);
            }
          });
        } else if (toString.call(wares) === '[object Array]') {
          wares.forEach(function (ware) {
            _this7.middleware(ware);
          });
        } else {
          throw new Error(ErrorType.MiddlewareInvalid);
        }
      });
      return this;
    }

    /**
     * Find parent's node
     * @param number
     */

  }, {
    key: 'parent',
    value: function parent() {
      var number = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

      return new Array(number).fill('').reduce(function (prev) {
        return prev._model.__parentPipe__;
      }, this)._model;
    }

    /**
     * Setting for states and update
     * @param states
     */

  }, {
    key: 'setState',
    value: function setState(states) {
      var _this8 = this;

      if (toString.call(states) === '[object Array]') {
        var _model;

        //TODO Array deep single re-assign or full coverage?
        (_model = this._model).splice.apply(_model, [0, this._model.length].concat(toConsumableArray(states)));
      } else if (toString.call(states) === '[object Object]') {
        Object.entries(states).filter(function (_ref12) {
          var _ref13 = slicedToArray(_ref12, 2),
              key = _ref13[0],
              value = _ref13[1];

          return typeof value !== 'function';
        }).forEach(function (_ref14) {
          var _ref15 = slicedToArray(_ref14, 2),
              key = _ref15[0],
              value = _ref15[1];

          var isInclude = Object.keys(_this8._model).includes(key);
          if (!isInclude) return null;
          if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
            _this8._model[key]['__pipe__'].setState(value);
          } else {
            _this8._model[key] = value;
          }
        });
      }
      return this._model;
    }

    /**
     * Getting full state
     */

  }, {
    key: 'getState',
    value: function getState() {
      return this.getStore({ withActions: false });
    }

    /**
     * Build a listen for the path key
     * @param path
     * @param listener
     * @returns {Pipe}
     */

  }, {
    key: 'listen',
    value: function listen(path, listener) {
      var _this9 = this;

      this.addObserver(function () {
        for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
          args[_key5] = arguments[_key5];
        }

        var updatePaths = args.slice(1, -2);
        if (typeof path === 'string') path = [path];
        var length = path.length;
        var isMatching = true;
        var isParentListener = false;
        for (var i = 0; i < length; i++) {
          if (path[i] !== updatePaths[i]) {
            isMatching = false;
            break;
          }
          if (i === length - 1 && updatePaths.length > length) {
            isParentListener = true;
          }
        }
        if (isMatching === false) return;
        var value = args.slice(-2, -1)[0];
        if (isParentListener) {
          value = _this9.get(path)['__pipe__'].getState();
        }
        listener(value, args);
      });
      return this;
    }

    /**
     * Get result value form paths
     * @param path
     */

  }, {
    key: 'get',
    value: function get$$1(path) {
      return get$1(this._model, path);
    }

    /**
     * Force update
     */

  }, {
    key: 'update',
    value: function update() {
      var _this10 = this;

      var paths = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      if (paths.length === 0) this._applyHookAfterReflector(this.getState(), { mode: 'batch' });
      paths.forEach(function (path) {
        if (!Array.isArray(path)) path = [path];
        var value = _this10.get(path);
        _this10._applyHookAfterReflector.apply(_this10, [value].concat(toConsumableArray(path), [{ mode: 'set' }]));
      });
    }

    /**
     * Get the store for the pipe
     * @param withActions
     * @returns {*}
     */

  }, {
    key: 'getStore',
    value: function getStore() {
      var _this11 = this;

      var _ref16 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref16$withActions = _ref16.withActions,
          withActions = _ref16$withActions === undefined ? true : _ref16$withActions;

      var state = Object.entries(this._model).filter(function (_ref17) {
        var _ref18 = slicedToArray(_ref17, 2),
            key = _ref18[0],
            value = _ref18[1];

        return withActions || typeof value !== 'function';
      }).reduce(function (state, _ref19) {
        var _ref20 = slicedToArray(_ref19, 2),
            key = _ref20[0],
            value = _ref20[1];

        if (Reflect.getOwnPropertyDescriptor(_this11._model, key).get) {
          return state;
        }
        if (value !== null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value['__pipe__']) {
          var _state = value['__pipe__'].getStore({ withActions: withActions });
          var isArray = toString.call(value) === '[object Array]';
          state[key] = isArray ? Array.from(_extends({}, _state, {
            length: Object.keys(_state).length
          })) : _state;
        } else {
          state[key] = value;
        }
        return state;
      }, {});
      if (Array.isArray(this._model)) {
        return Array.from(_extends({}, state, {
          length: this._model.length
        }));
      }
      return state;
    }

    /**
     * Handle origin store for immutable store
     * @returns {{root: *, __pipe__: Pipe}|*}
     */

  }, {
    key: 'getImmutableStore',
    value: function getImmutableStore() {
      var _this12 = this;

      if (this._store) {
        return this._store;
      }
      this._store = {
        root: this.getStore(),
        __pipe__: this
      };
      this.addObserver(function () {
        for (var _len6 = arguments.length, args = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
          args[_key6] = arguments[_key6];
        }

        var updatePaths = args.slice(1, -2);

        var _args$slice = args.slice(-2, -1),
            _args$slice2 = slicedToArray(_args$slice, 1),
            value = _args$slice2[0];

        var root = Array.isArray(_this12._store.root) ? [].concat(toConsumableArray(_this12._store.root)) : _extends({}, _this12._store.root);
        _this12._store.root = updatePaths.reduce(function (_ref21, path, key) {
          var current = _ref21.current,
              next = _ref21.next;

          var isLast = key === updatePaths.length - 1;
          next[path] = isLast ? value : Array.isArray(current[path]) ? [].concat(toConsumableArray(current[path])) : _extends({}, current[path]);
          if (isLast) {
            return root;
          }
          return {
            next: next[path],
            current: current[path]
          };
        }, {
          next: root,
          current: _this12._store.root
        });
      }, true); // Immutable Observer is earliest
      return this._store;
    }

    /**
     * Create a pipe model and assign initial values
     * @param initial
     * @returns {Proxy}
     */

  }, {
    key: 'create',
    value: function create() {
      var _this13 = this;

      var initial = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var initialValues = this._getInitialValues(initial);
      var entries = Object.entries(initialValues);
      var isArray = toString.call(this._model) === '[object Array]' && toString.call(initialValues) === '[object Array]' && initialValues.length > 0;
      if (isArray) {
        initialValues.forEach(function (item, key) {
          _this13._assign(item, key);
        });
      } else if (entries.length > 0) {
        entries.forEach(function (_ref22) {
          var _ref23 = slicedToArray(_ref22, 2),
              key = _ref23[0],
              item = _ref23[1];

          _this13._assign(item, key);
        });
      }
      this._isInitialized = true;
      this._update.isForce = true;
      return this._model;
    }
  }], [{
    key: '_isInstantiable',
    value: function _isInstantiable(item) {
      return ['[object Object]', '[object Array]'].includes(toString.call(item));
    }
  }, {
    key: '_isInstance',
    value: function _isInstance(item) {
      return item !== null && (typeof item === 'undefined' ? 'undefined' : _typeof(item)) === 'object' && item['__pipe__'] && item['__pipe__'].constructor === Pipe;
    }
  }]);
  return Pipe;
}(Observation);

function batch() {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  if (typeof args[0] === 'function') {
    var action = args[0],
        updatePaths = args.slice(1);

    return injectBatchUpdate(action, updatePaths);
  } else {
    return function (target, name, descriptor) {
      var value = descriptor.value;
      descriptor.value = injectBatchUpdate(value, args);
      return descriptor;
    };
  }
}

var injectBatchUpdate = function injectBatchUpdate(fn) {
  var updatePaths = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

  return function () {
    this['__pipe__']._update.isForce = false;

    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    var result = fn.apply(this, args);
    this['__pipe__']._update.isForce = true;
    this['__pipe__'].update(updatePaths);
    return result;
  };
};

var external = (function (func) {
  if (func) {
    return function __async__() {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return func.apply(this, args);
    };
  } else {
    return function (target, name, descriptor) {
      var fn = descriptor.value;
      descriptor.value = function __async__() {
        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        return fn.apply(this, args);
      };
      return descriptor;
    };
  }
});

var BaseHandle = function () {
  function BaseHandle() {
    classCallCheck(this, BaseHandle);
  }

  createClass(BaseHandle, null, [{
    key: 'getImmutable',
    value: function getImmutable(node) {
      return node['__pipe__'].getImmutableStore().root;
    }
  }, {
    key: 'getStore',
    value: function getStore(node, path) {
      return node.__pipe__.get(path);
    }
  }, {
    key: 'listen',
    value: function listen(node, path, callback) {
      return node.__pipe__.listen(path, callback);
    }
  }, {
    key: 'getState',
    value: function getState(node) {
      return node.__pipe__.getState();
    }
  }, {
    key: 'setState',
    value: function setState(node, state) {
      return node.__pipe__.setState(state);
    }
  }]);
  return BaseHandle;
}();

var pipe = function pipe(model) {
  return new Pipe(model);
};
var getImmutable = BaseHandle.getImmutable;
var getStore = BaseHandle.getStore;
var listen = BaseHandle.listen;
var getState = BaseHandle.getState;
var setState = BaseHandle.setState;

exports.getImmutable = getImmutable;
exports.getStore = getStore;
exports.listen = listen;
exports.getState = getState;
exports.setState = setState;
exports['default'] = pipe;
exports.iFlow = pipe;
exports.batch = batch;
exports.external = external;
exports.Pipe = Pipe;

Object.defineProperty(exports, '__esModule', { value: true });

})));
