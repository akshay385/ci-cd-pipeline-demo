{"version":3,"file":"index.min.js","sources":["../../lib/observation.js","../../lib/middleware.js","../../utils/warning.js","../../utils/isUnproxy.js","../../utils/tools.js","../../lib/pipe.js","../../lib/batch.js","../../lib/base.js","../../lib/index.js","../../lib/external.js"],"sourcesContent":["/* global toString */\nexport default class Observation {\n  /**\n   * observersQueue -> broadcast\n   * eventsQueue -> trigger\n   * receiversQueue -> subscribe\n   */\n  constructor () {\n    this._observersQueue = new Set()\n    this._dispatchersQueue = new Set()\n    this._receiversQueue = new Set()\n    this._broadcast = new Set()\n    this._subscribe = new Set()\n    this._trigger = new Set()\n  }\n\n  /**\n   *\n   * @param model\n   */\n  watch (model) {\n    const observer = this._observer.bind(this, model)\n    this._observe(observer)\n    this._observe(this._parentObserversQueue.bind(this))\n    const dispatcher = this._dispatcher.bind(this, model)\n    this._dispatch(dispatcher)\n    this._dispatch(this._parentDispatchersQueue.bind(this))\n    const receiver = this._receiver.bind(this, model)\n    this._receive(receiver)\n    this._receive(this._parentReceiversQueue.bind(this))\n  }\n\n  /**\n   *\n   * @param observer\n   * @private\n   */\n  _observe (observer) {\n    this._observersQueue.add(observer)\n  }\n\n  /**\n   *\n   * @param dispatcher\n   * @private\n   */\n  _dispatch (dispatcher) {\n    this._dispatchersQueue.add(dispatcher)\n  }\n\n  /**\n   *\n   * @param receiver\n   * @private\n   */\n  _receive (receiver) {\n    this._receiversQueue.add(receiver)\n  }\n\n  /**\n   *\n   * @param args\n   * @private\n   */\n  _observer (...args) {\n    this._broadcast.forEach(notice => notice(...args))\n  }\n\n  /**\n   *\n   * @param args\n   * @private\n   */\n  _parentObserversQueue (...args) {\n    this.parentObserversQueue && this.parentObserversQueue(...args)\n  }\n\n  /**\n   *\n   * @param args\n   * @private\n   */\n  _dispatcher (...args) {\n    return [...this._subscribe].reduce((prev, subscriber) => {\n      const isAsync = args.slice(-1)[0]\n      if (typeof prev === 'undefined') {\n        let result = subscriber(...args.slice(0, -1))\n        // separate async and sync dispatcher\n        if (\n          (!isAsync && toString.call(result) === '[object Promise]') ||\n          (isAsync && toString.call(result) !== '[object Promise]')\n        ) {\n          result = undefined\n        }\n        return result\n      } else {\n        let result = subscriber(...args.slice(0, -2), prev)\n        // separate async and sync dispatcher\n        if (\n          (!isAsync && toString.call(result) === '[object Promise]') ||\n          (isAsync && toString.call(result) !== '[object Promise]')\n        ) result = prev\n        return result || prev\n      }\n    }, undefined)\n  }\n\n  /**\n   *\n   * @param args\n   * @private\n   */\n  _parentDispatchersQueue (...args) {\n    return this.parentDispatchersQueue ? this.parentDispatchersQueue(...args) : undefined\n  }\n\n  /**\n   *\n   * @param args\n   * @private\n   */\n  _receiver (...args) {\n    this._trigger.forEach(trigger => trigger(...args))\n  }\n\n  /**\n   *\n   * @param args\n   * @private\n   */\n  _parentReceiversQueue (...args) {\n    this.parentReceiversQueue && this.parentReceiversQueue(...args)\n  }\n\n  /**\n   *\n   * @param item\n   * @param key\n   */\n  handleSubObserversQueue (item, key) {\n    const parentObserversQueue = (...args) => this._observersQueue.forEach(observer => observer(...args))\n    item.parentObserversQueue = parentObserversQueue.bind(Object.create(null), key)\n  }\n\n  /**\n   *\n   * @param item\n   * @param key\n   */\n  handleSubDispatchersQueue (item, key) {\n    const parentDispatchersQueue = (...args) => [...this._dispatchersQueue].reduce(\n      (prev, dispatcher) => dispatcher(...args) || prev,\n      undefined\n    )\n    item.parentDispatchersQueue = parentDispatchersQueue.bind(Object.create(null), key)\n  }\n\n  /**\n   *\n   * @param item\n   * @param key\n   */\n  handleSubReceiversQueue (item, key) {\n    const parentReceiversQueue = (...args) => this._receiversQueue.forEach(receiver => receiver(...args))\n    item.parentReceiversQueue = parentReceiversQueue.bind(Object.create(null), key)\n  }\n\n  /**\n   *\n   * @param notice\n   * @param isEarliest\n   * @returns {Observation}\n   */\n  addObserver (notice, isEarliest = false) {\n    if (typeof notice === 'function') {\n      if (isEarliest) {\n        this._broadcast = new Set([notice, ...this._broadcast])\n      } else {\n        this._broadcast.add(notice)\n      }\n    }\n    return this\n  }\n\n  /**\n   *\n   * @param notice\n   * @returns {Observation}\n   */\n  removeObserver (notice) {\n    if (typeof notice === 'function') this._broadcast.delete(notice)\n    return this\n  }\n\n  /**\n   *\n   * @param subscriber\n   * @returns {Observation}\n   */\n  addInterceptor (subscriber) {\n    if (typeof subscriber === 'function') this._subscribe.add(subscriber)\n    return this\n  }\n\n  /**\n   *\n   * @param trigger\n   * @returns {Observation}\n   */\n  addListener (trigger) {\n    if (typeof trigger === 'function') this._trigger.add(trigger)\n    return this\n  }\n\n  /**\n   *\n   * @param subscriber\n   * @returns {Observation}\n   */\n  removeInterceptor (subscriber) {\n    if (typeof subscriber === 'function') this._subscribe.delete(subscriber)\n    return this\n  }\n\n  /**\n   *\n   * @param trigger\n   * @returns {Observation}\n   */\n  removeListener (trigger) {\n    if (typeof trigger === 'function') this._trigger.delete(trigger)\n    return this\n  }\n\n}","/* global toString */\n\nexport default class Middleware {\n  /**\n   *\n   * @param pipe\n   */\n  constructor (pipe) {\n    this._middlewareQueue = new Set()\n    this._middleware = new Set()\n    this._applyMiddleware(pipe)\n  }\n\n  /**\n   *\n   * @param pipe\n   * @private\n   */\n  _applyMiddleware (pipe) {\n    pipe._middleware = this._middleware\n    pipe._middlewareQueue = this._middlewareQueue\n    pipe.handleSubMiddlewareQueue = this.handleSubMiddlewareQueue.bind(pipe)\n    const parentMiddlewareQueue = this._parentMiddlewareQueue.bind(pipe)\n    const runMiddleware = this._runMiddleware.bind(pipe)\n    this._addMiddleware([parentMiddlewareQueue, runMiddleware])\n  }\n\n  /**\n   *\n   * @param args\n   * @returns {undefined}\n   * @private\n   */\n  _parentMiddlewareQueue (...args) {\n    return this.parentMiddlewareQueue ? this.parentMiddlewareQueue(...args) : undefined\n  }\n\n  /**\n   *\n   * @param args\n   * @returns {*}\n   * @private\n   */\n  _runMiddleware (...args) {\n    return [...this._middleware].reduce((prev, middleware) => {\n      // if middleware reduce cover prev value it could use `middleware(...args) || prev`\n      if (typeof prev === 'undefined') {\n        return middleware(...args)\n      } else {\n        return middleware(...args.slice(0, -1), prev) || prev\n      }\n    }, undefined)\n  }\n\n  /**\n   *\n   * @param middleware\n   * @private\n   */\n  _addMiddleware (middleware) {\n    if (toString.call(middleware) === '[object Array]') {\n      middleware.forEach(this._addMiddleware.bind(this))\n    }\n    if (typeof middleware === 'function') {\n      this._middlewareQueue.add(middleware)\n    }\n  }\n\n  /**\n   *\n   * @param item\n   * @param key\n   */\n  handleSubMiddlewareQueue (item, key) {\n    const parentMiddlewareQueue = (...args) => [...this._middlewareQueue].reduce(\n      (prev, middleware) => middleware(...args) || prev,\n      undefined\n    )\n    item.parentMiddlewareQueue = parentMiddlewareQueue.bind(Object.create(null), key)\n  }\n\n  /**\n   *\n   * @param middleware\n   */\n  addMiddleware (middleware) {\n    if (toString.call(middleware) === '[object Array]') {\n      middleware.forEach(this.addMiddleware.bind(this))\n    }\n    if (typeof middleware === 'function') {\n      this._middleware.add(middleware.bind(Object.create(null), this._model))\n    }\n    return this\n  }\n\n}","const ErrorType = {\n  DuplicateCreate: `The Model have been created, and recheck it 'create' API invoke config.`,\n  MiddlewareInvalid: `The Middleware is invalid, and recheck it 'middleware' API invoke config.`,\n}\n\nexport {\n  ErrorType as default\n}","/* global toString */\n\nconst unProxyTypes = [\n  '[object Set]',\n  '[object WeakSet]',\n  '[object Map]',\n  '[object WeakMap]'\n]\n\nexport default (target) => unProxyTypes.includes(toString.call(target))","/* global toString */\nconst INFINITY = 1 / 0\n\nexport const isSymbol = (value) => {\n  const type = typeof value\n  return type === 'symbol' || (type === 'object' && value !== null && toString.call(value) === '[object Symbol]')\n}\n\nexport const toKey = (value) => {\n  if (typeof value === 'string' || isSymbol(value)) {\n    return value\n  }\n  const result = `${value}`\n  return (result === '0' && (1 / value) === -INFINITY) ? '-0' : result\n}\n\nexport const get = (object, path) => {\n  if (typeof path === 'string') path = [path]\n  let index = 0\n  const length = path.length\n  while (object !== null && index < length) {\n    object = object[toKey(path[index++])]\n  }\n  return (index && index === length) ? object : undefined\n}","import Observation from './observation'\nimport Middleware from './middleware'\nimport warning from '../utils/warning'\nimport isUnproxy from '../utils/isUnproxy'\nimport { get } from '../utils/tools'\n\n/* global toString */\n\n//TODO separate update config\nconst update = {\n  isForce: false\n}\n\nclass Pipe extends Observation {\n  /**\n   *\n   * iFlow's Pipe Model build on observer mode\n   * data flow:\n   *\n   *      action -> middleware -> reflector -> observer\n   *        |                                       |\n   *      store <------------ iFlow ------------- state\n   *\n   * @param originalModel\n   * @param autoInitialize\n   * @returns {*}\n   */\n  constructor (originalModel, {autoInitialize = false} = {}) {\n    super(originalModel)\n    this._originalModel = originalModel\n    this._isInitialized = false\n    this._update = update\n    this._initialValues = new Set()\n    this._model = isUnproxy(originalModel) ? originalModel : new Proxy(originalModel, {\n      set: this._setterProxy.bind(this),\n      deleteProperty: this._deleteProperty.bind(this)\n    })\n    this.addMiddleware = new Middleware(this).addMiddleware.bind(this)\n    this._setup(this._model)\n    // root pipe\n    const isSettable = !isUnproxy(this._model) && !this._model['__pipe__'] && Object.isExtensible(this._model)\n    isSettable && Reflect.defineProperty(this._model, '__pipe__', {\n      value: this,\n      configurable: false,\n      enumerable: false,\n      writable: false,\n    })\n    if (autoInitialize) {\n      this._isInitialized = true\n      return this._model\n    }\n  }\n\n  /**\n   * Activate watchers use observers queue.\n   * Action functions is inserted extra actions.\n   * @param model\n   * @private\n   */\n  _setup (model) {\n    this.watch(model)\n    this._insertActionsInjector(model)\n  }\n\n  /**\n   * Actions respectively inserted\n   * @param model\n   * @private\n   */\n  _insertActionsInjector (model) {\n    this._setActions(model)\n    if (toString.call(model) === '[object Object]') {\n      this._setProtoActions(model)\n    }\n  }\n\n  /**\n   * Plain actions setters\n   * @param model\n   * @private\n   */\n  _setActions (model) {\n    Reflect\n      .ownKeys(model)\n      .forEach((key) => {\n        let descriptor = Reflect.getOwnPropertyDescriptor(model, key)\n        const property = this._rebindAction(descriptor, model, key)\n        Reflect.defineProperty(model, key, property)\n      })\n  }\n\n  /**\n   * Check pipe model instantiable type\n   * @param item\n   * @returns {boolean}\n   */\n  static _isInstantiable (item) {\n    return ['[object Object]', '[object Array]'].includes(toString.call(item))\n  }\n\n  /**\n   * Current model's proto reset descriptor\n   * @param model\n   * @private\n   */\n  _setProtoActions (model) {\n    Reflect\n      .ownKeys(model.__proto__)\n      .forEach((key) => {\n        if (!Reflect.ownKeys({}.__proto__).includes(key)) {\n          let descriptor = Reflect.getOwnPropertyDescriptor(model.__proto__, key)\n          const property = {\n            ...this._rebindAction(descriptor, model, key),\n            enumerable: true,\n          }\n          Reflect.defineProperty(model, key, property)\n        }\n      })\n  }\n\n  /**\n   * Register sub Pipe actions transmitter\n   * @param item\n   * @param key\n   * @private\n   */\n  _handleSubPipe (item, key) {\n    this._handleParentNode(item)\n    this.handleSubObserversQueue(item, key)\n    this.handleSubDispatchersQueue(item, key)\n    this.handleSubReceiversQueue(item, key)\n    this.handleSubMiddlewareQueue(item, key)\n  }\n\n  /**\n   * Inject parent node\n   * @param item\n   * @private\n   */\n  _handleParentNode (item) {\n    const isSettable = !isUnproxy(item._model) && item._model && !item._model.__parentPipe__ && Object.isExtensible(item._model)\n    isSettable && Reflect.defineProperty(item._model, '__parentPipe__', {\n      value: this,\n      configurable: false,\n      enumerable: false,\n      writable: false,\n    })\n  }\n\n  /**\n   * Check return pipe model instance\n   * @param item\n   * @returns {boolean}\n   * @private\n   */\n  static _isInstance (item) {\n    return (\n      item !== null &&\n      typeof item === 'object' &&\n      item['__pipe__'] &&\n      item['__pipe__'].constructor === Pipe\n    )\n  }\n\n  /**\n   * Bind plain actions hook\n   * @param model\n   * @param item\n   * @param key\n   * @returns {function(...[*])}\n   * @private\n   */\n  _rebindModelAction (model, item, key) {\n    return (...args) => {\n      const fn = item.bind(model, ...args, model)\n      return this._handleTypeFunc(fn, [\n        this.beforeActionHook.bind(this, key, model, args),\n        this.afterActionHook.bind(this, key, model)\n      ], [item, model])\n    }\n  }\n\n  /**\n   * Bind actions hook\n   * @param descriptor\n   * @param model\n   * @param key\n   * @returns {*}\n   * @private\n   */\n  _rebindAction (descriptor, model, key) {\n    //TODO ['value', 'get', 'set']?\n    const descriptorFields = ['value', 'set']\n    return descriptorFields.reduce((descriptor, field) => {\n      // skip __pipe__ or __parentPipe__ property\n      if (['__pipe__', '__parentPipe__'].includes(key)) return descriptor\n      if (descriptor[field] && typeof descriptor[field] === 'function') {\n        const fn = (...args) => {\n          const fn = descriptor[field].bind(model, ...args, model)\n          return this._handleTypeFunc(fn, [\n            this.beforeActionHook.bind(this, key, model, args),\n            this.afterActionHook.bind(this, key, model)\n          ], [descriptor[field], model, field])\n        }\n        return {\n          ...descriptor,\n          [field]: fn\n        }\n      } else if (field === 'value' && descriptor.value && typeof descriptor.value === 'object') {\n        const item = descriptor.value\n        let value = item\n        if (item.constructor === Pipe) {\n          if (!item._model.__parentPipe__) {\n            this._handleSubPipe(item, key)\n            value = item.create()\n          } else {\n            const pipe = new Pipe(item._model)\n            this._handleSubPipe(pipe, key)\n            value = pipe.create()\n            const parent = item._model.__parentPipe__._model\n            Reflect\n              .ownKeys(parent)\n              .forEach(key => {\n                if (parent[key] === item._originalModel) {\n                  Reflect.defineProperty(parent, key, {\n                    ...Reflect.getOwnPropertyDescriptor(parent, key),\n                    value\n                  })\n                }\n              })\n          }\n        } else if (Pipe._isInstance(item)) {\n          if (!item.__parentPipe__) {\n            this._handleSubPipe(item.__pipe__, key)\n          } else {\n            const pipe = new Pipe(item)\n            this._handleSubPipe(pipe, key)\n            value = pipe.create()\n            const parent = item.__parentPipe__._model\n            Reflect\n              .ownKeys(parent)\n              .forEach(key => {\n                if (parent[key] === item) {\n                  Reflect.defineProperty(parent, key, {\n                    ...Reflect.getOwnPropertyDescriptor(parent, key),\n                    value\n                  })\n                }\n              })\n          }\n        } else if (Pipe._isInstantiable(item)) {\n          value = new Pipe(item, {autoInitialize: true})\n          this._handleSubPipe(value['__pipe__'], key)\n        }\n        return {\n          ...descriptor,\n          value\n        }\n      } else {\n        return descriptor\n      }\n    }, descriptor)\n  }\n\n  /**\n   * The core proxy states setter\n   * @param target\n   * @param key\n   * @param value\n   * @param receiver\n   * @returns {boolean}\n   * @private\n   */\n  _setterProxy (target, key, value, receiver) {\n    const assignment = this._applyHookBeforeReflector(value, key, {mode: 'set'})\n    // TODO force setter ?\n    // if (assignment === target[key]) return true\n    const result = Reflect.set(target, key, assignment, receiver)\n    this._applyHookAfterReflector(assignment, key, {mode: 'set'})\n    return result\n  }\n\n  /**\n   * The core proxy states deleter\n   * @param target\n   * @param key\n   * @returns {boolean}\n   * @private\n   */\n  _deleteProperty (target, key) {\n    this._applyHookBeforeReflector(target[key], key, {mode: 'delete'})\n    const deletePropertyResult = Reflect.deleteProperty(target, key)\n    this._applyHookAfterReflector(target[key], key, {mode: 'delete'})\n    return deletePropertyResult\n  }\n\n  /**\n   * Handle hook before state change value\n   * @param value\n   * @param key\n   * @param params\n   * @returns {*}\n   * @private\n   */\n  _applyHookBeforeReflector (value, key, params) {\n    let assignment = value\n    const isSkipHook = this._isSkipHook(key)\n    if (isSkipHook) {\n      return assignment\n    }\n    if (typeof value === 'function' && params.mode === 'set') {\n      assignment = this._rebindModelAction(this._model, value, key)\n    }\n    if (typeof value !== 'function' && this._isInitialized && this._update.isForce && this._update.isForce) {\n      assignment = [...this._middlewareQueue].reduce(\n        (assignment, middleware) => {\n          const evaluation = middleware(key, assignment, params)\n          const isValid = typeof evaluation !== 'undefined'\n          return isValid ? evaluation : assignment\n        },\n        assignment\n      )\n    }\n    // Insert dynamic state\n    if (typeof assignment === 'object' && params.mode === 'set') {\n      const dynamicState = new Pipe(assignment)\n      assignment = dynamicState.create()\n      this._handleSubPipe(dynamicState, key)\n    }\n    return assignment\n  }\n\n  /**\n   * Handle hook after state change value\n   * @param args\n   * @returns {null}\n   * @private\n   */\n  _applyHookAfterReflector (...args) {\n    const assignment = args[0]\n    const keys = args.slice(1, -1)\n    const params = args.slice(-1)[0]\n    // TODO process batch isSkipHook\n    const isSkipHook = this._isSkipHook(keys[0])\n    if (isSkipHook) {\n      return null\n    }\n    if (typeof assignment !== 'function' && this._isInitialized && this._update.isForce && this._update.isForce) {\n      this._observersQueue.forEach(observer => observer(...keys, assignment, params))\n    }\n  }\n\n  /**\n   * Check to return is-skip hook\n   * Non primitive data types skip hook\n   * @param key\n   * @returns {boolean}\n   * @private\n   */\n  _isSkipHook (key) {\n    // TODO remove it?\n    // const isChangeArrayLength = key === 'length' && toString.call(this._model) === '[object Array]'\n    return (\n      !this._isInitialized || !this._update.isForce // || isChangeArrayLength\n    )\n  }\n\n  /**\n   * Handle before action hook\n   * @param key\n   * @param model\n   * @param args\n   * @param async\n   * @returns {*}\n   */\n  beforeActionHook (key, model, args, {async} = {}) {\n    if (this._isInitialized && this._update.isForce) {\n      let result = args\n      for (const dispatcher of [...this._dispatchersQueue]) {\n        if (async) {\n          const dispatcherResult = dispatcher(key, model, result, async)\n          if (dispatcherResult) result = dispatcherResult\n        } else {\n          const dispatcherResult = dispatcher(key, model, result, async)\n          if (\n            dispatcherResult &&\n            Array.isArray(dispatcherResult) &&\n            !dispatcherResult.some(i => toString.call(i) === '[object Promise]')\n          ) result = dispatcherResult\n        }\n      }\n      if (result !== args) {\n        return result\n      }\n    }\n  }\n\n  /**\n   * Handle after action hook\n   * @param key\n   * @param model\n   * @returns {Promise.<void>}\n   */\n  afterActionHook (key, model) {\n    if (this._isInitialized && this._update.isForce) {\n      for (const receiver of [...this._receiversQueue]) {\n        receiver(key, model)\n      }\n    }\n  }\n\n  /**\n   * Handle actions with actions hook\n   * @param fn\n   * @param beforeHook\n   * @param afterHook\n   * @param item\n   * @param model\n   * @returns {*}\n   * @private\n   */\n  _handleTypeFunc (fn, [beforeHook, afterHook], [item, model] = []) {\n    if (\n      toString.call(fn) === '[object AsyncFunction]' ||\n      fn.name === 'bound __async__' ||\n      (fn.name === 'bound ' && fn.__proto__.name === '')\n    // When use strict, arguments.callee can not be accessed, so bound function name is empty string ''.\n    ) {\n      return (async () => {\n        let beforeHookResult = await (async () => beforeHook({async: true}))()\n        if (typeof beforeHookResult !== 'undefined') {\n          if (!Array.isArray(beforeHookResult)) beforeHookResult = [beforeHookResult]\n          fn = item.bind(model, ...beforeHookResult, model)\n        }\n        const result = await fn()\n        await (async () => afterHook())()\n        return result\n      })()\n    }\n    let beforeHookResult = beforeHook({async: false})\n    // if beforeHookResult is exist, it will replace the action parameters\n    if (typeof beforeHookResult !== 'undefined') {\n      if (!Array.isArray(beforeHookResult)) beforeHookResult = [beforeHookResult]\n      fn = item.bind(model, ...beforeHookResult, model)\n    }\n    const result = fn()\n    afterHook()\n    return result\n  }\n\n  /**\n   * Traverse initialValue's functions and reduce to get the initial values\n   * @param initial\n   * @returns {*}\n   * @private\n   */\n  _getInitialValues (initial) {\n    return [...this._initialValues].reduce((prev, getInitialValue) => {\n      const initialValue = getInitialValue(prev)\n      return typeof initialValue !== 'undefined' ? initialValue : prev\n    }, initial)\n  }\n\n  /**\n   * Assign initial values to pipe model\n   * @param item\n   * @param key\n   * @private\n   */\n  _assign (item, key) {\n    const descriptor = Object.getOwnPropertyDescriptor(this._model, key)\n    const isPrimitiveTypes = !descriptor || !['function', 'object'].includes(typeof descriptor.value)\n    const isExistValue = descriptor && typeof descriptor.value !== 'undefined'\n    if (isPrimitiveTypes) {\n      if (!isExistValue && Pipe._isInstantiable(item)) {\n        const pipe = new Pipe(item)\n        this._handleSubPipe(pipe, key)\n        this._model[key] = pipe.create()\n      } else {\n        this._model[key] = item\n      }\n    } else if (isExistValue && Pipe._isInstance(descriptor.value)) {\n      this._model[key] = this._model[key]['__pipe__'].create(item)\n    }\n  }\n\n  /**\n   * Set Initial function for getting initial value\n   * @param getInitial\n   * @returns {Pipe}\n   */\n  setInitializeValue (getInitial) {\n    if (typeof getInitial === 'function') this._initialValues.add(getInitial)\n    return this\n  }\n\n  /**\n   * Overall middleware control the Pipe store\n   * @param middleware\n   * @returns {Pipe}\n   */\n  middleware (...middleware) {\n    middleware.forEach(wares => {\n      if (typeof wares === 'function') {\n        this.addMiddleware(wares)\n      } else if (toString.call(wares) === '[object Object]') {\n        Object.entries(wares).forEach(([key, ware]) => {\n          switch (key) {\n            case 'stateWillInitialize':\n              return this.setInitializeValue(ware)\n            case 'actionWillStart':\n              return this.addInterceptor(ware) // support async\n            case 'stateWillChange':\n              return this.addMiddleware(ware)\n            case 'stateDidChange':\n              return this.addObserver(ware)\n            case 'actionDidEnd':\n              return this.addListener(ware) // support async\n            default:\n              throw new Error(warning.MiddlewareInvalid)\n          }\n        })\n      } else if (toString.call(wares) === '[object Array]') {\n        wares.forEach((ware) => {\n          this.middleware(ware)\n        })\n      } else {\n        throw new Error(warning.MiddlewareInvalid)\n      }\n    })\n    return this\n  }\n\n  /**\n   * Find parent's node\n   * @param number\n   */\n  parent (number = 1) {\n    return new Array(number).fill('').reduce((prev) => {\n      return prev._model.__parentPipe__\n    }, this)._model\n  }\n\n  /**\n   * Setting for states and update\n   * @param states\n   */\n  setState (states) {\n    if (toString.call(states) === '[object Array]') {\n      //TODO Array deep single re-assign or full coverage?\n      this._model.splice(0, this._model.length, ...states)\n    } else if (toString.call(states) === '[object Object]') {\n      Object\n        .entries(states)\n        .filter(([key, value]) => typeof value !== 'function')\n        .forEach(([key, value]) => {\n          const isInclude = Object.keys(this._model).includes(key)\n          if (!isInclude) return null\n          if (typeof value === 'object') {\n            this._model[key]['__pipe__'].setState(value)\n          } else {\n            this._model[key] = value\n          }\n        })\n    }\n    return this._model\n  }\n\n  /**\n   * Getting full state\n   */\n  getState () {\n    return this.getStore({withActions: false})\n  }\n\n  /**\n   * Build a listen for the path key\n   * @param path\n   * @param listener\n   * @returns {Pipe}\n   */\n  listen (path, listener) {\n    this.addObserver((...args) => {\n      const updatePaths = args.slice(1, -2)\n      if (typeof path === 'string') path = [path]\n      const length = path.length\n      let isMatching = true\n      let isParentListener = false\n      for (let i = 0; i < length; i++) {\n        if (path[i] !== updatePaths[i]) {\n          isMatching = false\n          break\n        }\n        if (i === length - 1 && updatePaths.length > length) {\n          isParentListener = true\n        }\n      }\n      if (isMatching === false) return\n      let value = args.slice(-2, -1)[0]\n      if (isParentListener) {\n        value = this.get(path)['__pipe__'].getState()\n      }\n      listener(value, args)\n    })\n    return this\n  }\n\n  /**\n   * Get result value form paths\n   * @param path\n   */\n  get (path) {\n    return get(this._model, path)\n  }\n\n  /**\n   * Force update\n   */\n  update (paths = []) {\n    if (paths.length === 0) this._applyHookAfterReflector(this.getState(), {mode: 'batch'})\n    paths.forEach(path => {\n      if (!Array.isArray(path)) path = [path]\n      const value = this.get(path)\n      this._applyHookAfterReflector(value, ...path, {mode: 'set'})\n    })\n  }\n\n  /**\n   * Get the store for the pipe\n   * @param withActions\n   * @returns {*}\n   */\n  getStore ({withActions = true} = {}) {\n    const state = Object\n      .entries(this._model)\n      .filter(([key, value]) => withActions || typeof value !== 'function')\n      .reduce((state, [key, value]) => {\n        if (Reflect.getOwnPropertyDescriptor(this._model, key).get) {\n          return state\n        }\n        if (value !== null && typeof value === 'object' && value['__pipe__']) {\n          const _state = value['__pipe__'].getStore({withActions})\n          const isArray = toString.call(value) === '[object Array]'\n          state[key] = isArray ? Array.from({\n            ..._state,\n            length: Object.keys(_state).length\n          }) : _state\n        } else {\n          state[key] = value\n        }\n        return state\n      }, {})\n    if (Array.isArray(this._model)) {\n      return Array.from({\n        ...state,\n        length: this._model.length\n      })\n    }\n    return state\n  }\n\n  /**\n   * Handle origin store for immutable store\n   * @returns {{root: *, __pipe__: Pipe}|*}\n   */\n  getImmutableStore () {\n    if (this._store) {\n      return this._store\n    }\n    this._store = {\n      root: this.getStore(),\n      __pipe__: this,\n    }\n    this.addObserver((...args) => {\n      const updatePaths = args.slice(1, -2)\n      const [value] = args.slice(-2, -1)\n      let root = Array.isArray(this._store.root) ? [...this._store.root] : {...this._store.root}\n      this._store.root = updatePaths.reduce(({current, next}, path, key) => {\n        const isLast = key === updatePaths.length - 1\n        next[path] = isLast ? value : (\n          Array.isArray(current[path]) ? [...current[path]] : {...current[path]}\n        )\n        if (isLast) {\n          return root\n        }\n        return {\n          next: next[path],\n          current: current[path],\n        }\n      }, {\n        next: root,\n        current: this._store.root,\n      })\n    }, true) // Immutable Observer is earliest\n    return this._store\n  }\n\n  /**\n   * Create a pipe model and assign initial values\n   * @param initial\n   * @returns {Proxy}\n   */\n  create (initial = {}) {\n    const initialValues = this._getInitialValues(initial)\n    const entries = Object.entries(initialValues)\n    const isArray = (\n      toString.call(this._model) === '[object Array]' &&\n      toString.call(initialValues) === '[object Array]' &&\n      initialValues.length > 0\n    )\n    if (isArray) {\n      initialValues.forEach((item, key) => {\n        this._assign(item, key)\n      })\n    } else if (entries.length > 0) {\n      entries\n        .forEach(([key, item]) => {\n          this._assign(item, key)\n        })\n    }\n    this._isInitialized = true\n    this._update.isForce = true\n    return this._model\n  }\n}\n\nexport default Pipe\n","export default function batch (...args) {\n  if (typeof args[0] === 'function') {\n    const [action, ...updatePaths] = args\n    return injectBatchUpdate(action, updatePaths)\n  } else {\n    return (target, name, descriptor) => {\n      let value = descriptor.value\n      descriptor.value = injectBatchUpdate(value, args)\n      return descriptor\n    }\n  }\n}\n\nconst injectBatchUpdate = (fn, updatePaths = []) => {\n  return function (...args) {\n    this['__pipe__']._update.isForce = false\n    const result = fn.apply(this, args)\n    this['__pipe__']._update.isForce = true\n    this['__pipe__'].update(updatePaths)\n    return result\n  }\n}\n","export default class BaseHandle {\n  static getImmutable (node) {\n    return node['__pipe__'].getImmutableStore().root\n  }\n\n  static getStore (node, path) {\n    return node.__pipe__.get(path)\n  }\n\n  static listen (node, path, callback) {\n    return node.__pipe__.listen(path, callback)\n  }\n\n  static getState (node) {\n    return node.__pipe__.getState()\n  }\n\n  static setState (node, state) {\n    return node.__pipe__.setState(state)\n  }\n}","import Pipe from './pipe'\nimport batch from './batch'\nimport external from './external'\nimport base from './base'\n\nconst pipe = (model) => new Pipe(model)\nexport const {\n  getImmutable,\n  getStore,\n  listen,\n  getState,\n  setState\n} = base\n\nexport {\n  pipe as default,\n  pipe as iFlow,\n  batch,\n  external,\n  Pipe,\n}\n","export default (func) => {\n  if (func) {\n    return function __async__ (...args) {\n      return func.apply(this, args)\n    }\n  } else {\n    return (target, name, descriptor) => {\n      let fn = descriptor.value\n      descriptor.value = function __async__ (...args) {\n        return fn.apply(this, args)\n      }\n      return descriptor\n    }\n  }\n}"],"names":["Observation","_observersQueue","Set","_dispatchersQueue","_receiversQueue","_broadcast","_subscribe","_trigger","model","observer","this","_observer","bind","_observe","_parentObserversQueue","dispatcher","_dispatcher","_dispatch","_parentDispatchersQueue","receiver","_receiver","_receive","_parentReceiversQueue","add","args","forEach","notice","parentObserversQueue","reduce","prev","subscriber","isAsync","slice","result","toString","call","undefined","parentDispatchersQueue","trigger","parentReceiversQueue","item","key","_this","Object","create","_this2","_this3","isEarliest","delete","Middleware","pipe","_middlewareQueue","_middleware","_applyMiddleware","handleSubMiddlewareQueue","parentMiddlewareQueue","_parentMiddlewareQueue","runMiddleware","_runMiddleware","_addMiddleware","middleware","addMiddleware","_model","ErrorType","unProxyTypes","target","includes","toKey","value","type","isSymbol","update","Pipe","originalModel","autoInitialize","_originalModel","_isInitialized","_update","_initialValues","isUnproxy","Proxy","_setterProxy","_deleteProperty","_setup","isExtensible","Reflect","defineProperty","watch","_insertActionsInjector","_setActions","_setProtoActions","ownKeys","descriptor","getOwnPropertyDescriptor","property","_rebindAction","__proto__","_handleParentNode","handleSubObserversQueue","handleSubDispatchersQueue","handleSubReceiversQueue","__parentPipe__","fn","_this4","_handleTypeFunc","beforeActionHook","afterActionHook","field","_this5","babelHelpers.typeof","constructor","_handleSubPipe","parent","_isInstance","__pipe__","_isInstantiable","assignment","_applyHookBeforeReflector","mode","set","_applyHookAfterReflector","deletePropertyResult","deleteProperty","params","_isSkipHook","_rebindModelAction","isForce","evaluation","dynamicState","keys","async","dispatcherResult","Array","isArray","some","i","beforeHook","afterHook","name","babelHelpers.asyncToGenerator","beforeHookResult","initial","getInitialValue","initialValue","isPrimitiveTypes","isExistValue","getInitial","wares","entries","ware","_this7","setInitializeValue","addInterceptor","addObserver","addListener","Error","warning","number","fill","states","splice","length","filter","_this8","setState","getStore","withActions","path","listener","updatePaths","isMatching","isParentListener","_this9","get","getState","object","index","paths","_this10","state","_this11","_state","from","_store","root","_this12","current","next","isLast","initialValues","_getInitialValues","_assign","injectBatchUpdate","apply","BaseHandle","node","getImmutableStore","callback","listen","getImmutable","base","action","func"],"mappings":"61DACqBA,yCAOZC,gBAAkB,IAAIC,SACtBC,kBAAoB,IAAID,SACxBE,gBAAkB,IAAIF,SACtBG,WAAa,IAAIH,SACjBI,WAAa,IAAIJ,SACjBK,SAAW,IAAIL,4CAOfM,OACCC,EAAWC,KAAKC,UAAUC,KAAKF,KAAMF,QACtCK,SAASJ,QACTI,SAASH,KAAKI,sBAAsBF,KAAKF,WACxCK,EAAaL,KAAKM,YAAYJ,KAAKF,KAAMF,QAC1CS,UAAUF,QACVE,UAAUP,KAAKQ,wBAAwBN,KAAKF,WAC3CS,EAAWT,KAAKU,UAAUR,KAAKF,KAAMF,QACtCa,SAASF,QACTE,SAASX,KAAKY,sBAAsBV,KAAKF,wCAQtCD,QACHR,gBAAgBsB,IAAId,qCAQhBM,QACJZ,kBAAkBoB,IAAIR,oCAQnBI,QACHf,gBAAgBmB,IAAIJ,kEAQbK,8CACPnB,WAAWoB,QAAQ,mBAAUC,eAAUF,0DASvCG,sBAAwBjB,KAAKiB,4GAQpBH,2DACHd,KAAKJ,aAAYsB,OAAO,SAACC,EAAMC,OAClCC,EAAUP,EAAKQ,OAAO,GAAG,WACX,IAATH,EAAsB,KAC3BI,EAASH,iBAAcN,EAAKQ,MAAM,GAAI,aAGtCD,GAAqC,qBAA1BG,SAASC,KAAKF,IAC1BF,GAAqC,qBAA1BG,SAASC,KAAKF,aAEjBG,GAEJH,MAEHA,EAASH,iBAAcN,EAAKQ,MAAM,GAAI,YAAIH,aAG1CE,GAAqC,qBAA1BG,SAASC,KAAKF,IAC1BF,GAAqC,qBAA1BG,SAASC,KAAKF,MAC1BA,EAASJ,GACJI,GAAUJ,QAElBO,4DASI1B,KAAK2B,uBAAyB3B,KAAK2B,kDAAkCD,iEAQhEZ,8CACPjB,SAASkB,QAAQ,mBAAWa,eAAWd,0DASvCe,sBAAwB7B,KAAK6B,2FAQXC,EAAMC,gBAExBd,qBADwB,sCAAIH,gDAASkB,EAAKzC,gBAAgBwB,QAAQ,mBAAYhB,eAAYe,MAC9CZ,KAAK+B,OAAOC,OAAO,MAAOH,qDAQlDD,EAAMC,gBAK1BJ,uBAJ0B,sCAAIb,2DAAaqB,EAAK1C,oBAAmByB,OACtE,SAACC,EAAMd,UAAeA,eAAcS,IAASK,QAC7CO,IAEmDxB,KAAK+B,OAAOC,OAAO,MAAOH,mDAQxDD,EAAMC,gBAExBF,qBADwB,sCAAIf,gDAASsB,EAAK1C,gBAAgBqB,QAAQ,mBAAYN,eAAYK,MAC9CZ,KAAK+B,OAAOC,OAAO,MAAOH,uCAShEf,OAAQqB,gEACG,mBAAXrB,IACLqB,OACG1C,WAAa,IAAIH,KAAKwB,YAAWhB,KAAKL,mBAEtCA,WAAWkB,IAAIG,IAGjBhB,4CAQOgB,SACQ,mBAAXA,GAAuBhB,KAAKL,WAAW2C,OAAOtB,GAClDhB,4CAQOoB,SACY,mBAAfA,GAA2BpB,KAAKJ,WAAWiB,IAAIO,GACnDpB,yCAQI4B,SACY,mBAAZA,GAAwB5B,KAAKH,SAASgB,IAAIe,GAC9C5B,+CAQUoB,SACS,mBAAfA,GAA2BpB,KAAKJ,WAAW0C,OAAOlB,GACtDpB,4CAQO4B,SACS,mBAAZA,GAAwB5B,KAAKH,SAASyC,OAAOV,GACjD5B,cCrOUuC,wBAKNC,kBACNC,iBAAmB,IAAIjD,SACvBkD,YAAc,IAAIlD,SAClBmD,iBAAiBH,sDAQNA,KACXE,YAAc1C,KAAK0C,cACnBD,iBAAmBzC,KAAKyC,mBACxBG,yBAA2B5C,KAAK4C,yBAAyB1C,KAAKsC,OAC7DK,EAAwB7C,KAAK8C,uBAAuB5C,KAAKsC,GACzDO,EAAgB/C,KAAKgD,eAAe9C,KAAKsC,QAC1CS,gBAAgBJ,EAAuBE,4DAUrC/C,KAAK6C,sBAAwB7C,KAAK6C,iDAAiCnB,sEASzDZ,2DACNd,KAAK0C,cAAaxB,OAAO,SAACC,EAAM+B,eAErB,IAAT/B,EACF+B,eAAcpC,GAEdoC,iBAAcpC,EAAKQ,MAAM,GAAI,YAAIH,MAASA,QAElDO,0CAQWwB,GACoB,mBAA9B1B,SAASC,KAAKyB,MACLnC,QAAQf,KAAKiD,eAAe/C,KAAKF,OAEpB,mBAAfkD,QACJT,iBAAiB5B,IAAIqC,oDASJpB,EAAMC,gBAKzBc,sBAJyB,sCAAI/B,2DAAakB,EAAKS,mBAAkBvB,OACpE,SAACC,EAAM+B,UAAeA,eAAcpC,IAASK,QAC7CO,IAEiDxB,KAAK+B,OAAOC,OAAO,MAAOH,yCAOhEmB,SACqB,mBAA9B1B,SAASC,KAAKyB,MACLnC,QAAQf,KAAKmD,cAAcjD,KAAKF,OAEnB,mBAAfkD,QACJR,YAAY7B,IAAIqC,EAAWhD,KAAK+B,OAAOC,OAAO,MAAOlC,KAAKoD,SAE1DpD,cC5FLqD,8ECEAC,GACJ,eACA,mBACA,eACA,+BAGcC,UAAWD,EAAaE,SAAShC,SAASC,KAAK8B,KCDlDE,EAAQ,SAACC,MACC,iBAAVA,GANW,SAACA,OACjBC,WAAcD,gBAAAA,SACJ,WAATC,GAA+B,WAATA,GAA+B,OAAVD,GAA2C,oBAAzBlC,SAASC,KAAKiC,GAIjDE,CAASF,UACjCA,MAEHnC,KAAYmC,QACC,MAAXnC,GAAmB,EAAImC,IAZhB,EAAA,EAYwC,KAAOnC,GCJ1DsC,YACK,GAGLC,2UAAaxE,cAcJyE,qEAAgBC,eAAAA,yFACrBD,MACDE,eAAiBF,IACjBG,gBAAiB,IACjBC,QAAUN,IACVO,eAAiB,IAAI5E,MACrB4D,OAASiB,EAAUN,GAAiBA,EAAgB,IAAIO,MAAMP,OAC5D/B,EAAKuC,aAAarE,uBACP8B,EAAKwC,gBAAgBtE,YAElCiD,cAAgB,IAAIZ,KAAiBY,cAAcjD,UACnDuE,OAAOzC,EAAKoB,YAEGiB,EAAUrC,EAAKoB,UAAYpB,EAAKoB,OAAL,UAA2BnB,OAAOyC,aAAa1C,EAAKoB,SACrFuB,QAAQC,eAAe5C,EAAKoB,OAAQ,kCAElC,cACF,YACF,IAERY,EAAgB,gBACbE,gBAAiB,IACflC,EAAKoB,gEAURtD,QACD+E,MAAM/E,QACNgF,uBAAuBhF,kDAQNA,QACjBiF,YAAYjF,GACY,oBAAzB0B,SAASC,KAAK3B,SACXkF,iBAAiBlF,uCASbA,sBAERmF,QAAQnF,GACRiB,QAAQ,SAACgB,OACJmD,EAAaP,QAAQQ,yBAAyBrF,EAAOiC,GACnDqD,EAAWjD,EAAKkD,cAAcH,EAAYpF,EAAOiC,WAC/C6C,eAAe9E,EAAOiC,EAAKqD,8CAkBvBtF,sBAEbmF,QAAQnF,EAAMwF,WACdvE,QAAQ,SAACgB,OACH4C,QAAQM,WAAWK,WAAW9B,SAASzB,GAAM,KAC5CmD,EAAaP,QAAQQ,yBAAyBrF,EAAMwF,UAAWvD,GAC7DqD,OACDhD,EAAKiD,cAAcH,EAAYpF,EAAOiC,gBAC7B,YAEN6C,eAAe9E,EAAOiC,EAAKqD,6CAW3BtD,EAAMC,QACfwD,kBAAkBzD,QAClB0D,wBAAwB1D,EAAMC,QAC9B0D,0BAA0B3D,EAAMC,QAChC2D,wBAAwB5D,EAAMC,QAC9Ba,yBAAyBd,EAAMC,6CAQnBD,IACGuC,EAAUvC,EAAKsB,SAAWtB,EAAKsB,SAAWtB,EAAKsB,OAAOuC,gBAAkB1D,OAAOyC,aAAa5C,EAAKsB,SACvGuB,QAAQC,eAAe9C,EAAKsB,OAAQ,wBACzCpD,mBACO,cACF,YACF,+CA2BMF,EAAOgC,EAAMC,qBACxB,sCAAIjB,6CACH8E,EAAK9D,EAAK5B,cAAKJ,UAAUgB,GAAMhB,YAC9B+F,EAAKC,gBAAgBF,GAC1BC,EAAKE,iBAAiB7F,OAAW6B,EAAKjC,EAAOgB,GAC7C+E,EAAKG,gBAAgB9F,OAAW6B,EAAKjC,KACnCgC,EAAMhC,2CAYCoF,EAAYpF,EAAOiC,qBAEN,QAAS,OACXb,OAAO,SAACgE,EAAYe,OAErC,WAAY,kBAAkBzC,SAASzB,GAAM,OAAOmD,KACrDA,EAAWe,IAAuC,mBAAtBf,EAAWe,GAAuB,aAS3Df,KARM,wCAAIpE,6CACP8E,OAAgBK,IAAO/F,cAAKJ,UAAUgB,GAAMhB,YAC3CoG,EAAKJ,gBAAgBF,GAC1BM,EAAKH,iBAAiB7F,OAAW6B,EAAKjC,EAAOgB,GAC7CoF,EAAKF,gBAAgB9F,OAAW6B,EAAKjC,KACnCoF,EAAWe,GAAQnG,EAAOmG,QAI7BA,qGAEE,GAAc,UAAVA,GAAqBf,EAAWxB,OAAqC,WAA5ByC,EAAOjB,EAAWxB,OAAoB,KAClF5B,EAAOoD,EAAWxB,MACpBA,EAAQ5B,KACRA,EAAKsE,cAAgBtC,KAClBhC,EAAKsB,OAAOuC,eAGV,KACCnD,EAAO,IAAIsB,EAAKhC,EAAKsB,UACtBiD,eAAe7D,EAAMT,KAClBS,EAAKN,aACPoE,EAASxE,EAAKsB,OAAOuC,eAAevC,eAEvC6B,QAAQqB,GACRvF,QAAQ,YACHuF,EAAOvE,KAASD,EAAKmC,wBACfW,eAAe0B,EAAQvE,OAC1B4C,QAAQQ,yBAAyBmB,EAAQvE,wBAZ/CsE,eAAevE,EAAMC,KAClBD,EAAKI,cAiBV,GAAI4B,EAAKyC,YAAYzE,MACrBA,EAAK6D,eAEH,KACCnD,EAAO,IAAIsB,EAAKhC,KACjBuE,eAAe7D,EAAMT,KAClBS,EAAKN,aACPoE,EAASxE,EAAK6D,eAAevC,eAEhC6B,QAAQqB,GACRvF,QAAQ,YACHuF,EAAOvE,KAASD,WACV8C,eAAe0B,EAAQvE,OAC1B4C,QAAQQ,yBAAyBmB,EAAQvE,wBAX/CsE,eAAevE,EAAK0E,SAAUzE,QAiB5B+B,EAAK2C,gBAAgB3E,OACtB,IAAIgC,EAAKhC,GAAOkC,gBAAgB,MACnCqC,eAAe3C,EAAA,SAAmB3B,gBAGpCmD,oBAIEA,aAERA,wCAYS3B,EAAQxB,EAAK2B,EAAOjD,OAC1BiG,EAAa1G,KAAK2G,0BAA0BjD,EAAO3B,GAAM6E,KAAM,QAG/DrF,EAASoD,QAAQkC,IAAItD,EAAQxB,EAAK2E,EAAYjG,eAC/CqG,yBAAyBJ,EAAY3E,GAAM6E,KAAM,QAC/CrF,0CAUQgC,EAAQxB,QAClB4E,0BAA0BpD,EAAOxB,GAAMA,GAAM6E,KAAM,eAClDG,EAAuBpC,QAAQqC,eAAezD,EAAQxB,eACvD+E,yBAAyBvD,EAAOxB,GAAMA,GAAM6E,KAAM,WAChDG,oDAWkBrD,EAAO3B,EAAKkF,OACjCP,EAAahD,KACE1D,KAAKkH,YAAYnF,UAE3B2E,KAEY,mBAAVhD,GAAwC,QAAhBuD,EAAOL,SAC3B5G,KAAKmH,mBAAmBnH,KAAKoD,OAAQM,EAAO3B,IAEtC,mBAAV2B,GAAwB1D,KAAKkE,gBAAkBlE,KAAKmE,QAAQiD,SAAWpH,KAAKmE,QAAQiD,wBAC5EpH,KAAKyC,mBAAkBvB,OACtC,SAACwF,EAAYxD,OACLmE,EAAanE,EAAWnB,EAAK2E,EAAYO,eACT,IAAfI,EACNA,EAAaX,GAEhCA,IAIsB,qBAAfA,gBAAAA,KAA2C,QAAhBO,EAAOL,KAAgB,KACrDU,EAAe,IAAIxD,EAAK4C,KACjBY,EAAapF,cACrBmE,eAAeiB,EAAcvF,UAE7B2E,gFASoB5F,6CACrB4F,EAAa5F,EAAK,GAClByG,EAAOzG,EAAKQ,MAAM,GAAI,GACtB2F,EAASnG,EAAKQ,OAAO,GAAG,MAEXtB,KAAKkH,YAAYK,EAAK,WAEhC,KAEiB,mBAAfb,GAA6B1G,KAAKkE,gBAAkBlE,KAAKmE,QAAQiD,SAAWpH,KAAKmE,QAAQiD,cAC7F7H,gBAAgBwB,QAAQ,mBAAYhB,iBAAYwH,WAAMb,EAAYO,2CAW9DlF,UAIR/B,KAAKkE,iBAAmBlE,KAAKmE,QAAQiD,iDAYxBrF,EAAKjC,EAAOgB,OAAO0G,8DAAAA,SAC/BxH,KAAKkE,gBAAkBlE,KAAKmE,QAAQiD,QAAS,SAC3C7F,EAAST,gBACgBd,KAAKP,uCAAoB,KAA3CY,UACLmH,EAAO,KACHC,EAAmBpH,EAAW0B,EAAKjC,EAAOyB,EAAQiG,GACpDC,IAAkBlG,EAASkG,OAC1B,KACCA,EAAmBpH,EAAW0B,EAAKjC,EAAOyB,EAAQiG,GAEtDC,GACAC,MAAMC,QAAQF,KACbA,EAAiBG,KAAK,kBAA0B,qBAArBpG,SAASC,KAAKoG,OAC1CtG,EAASkG,OAGXlG,IAAWT,SACNS,2CAWIQ,EAAKjC,MAChBE,KAAKkE,gBAAkBlE,KAAKmE,QAAQiD,8BACXpH,KAAKN,qCAAkB,UACvCqC,EAAKjC,4CAeH8F,yBAAKkC,OAAYC,4EAAajG,OAAMhC,UAE3B,2BAAtB0B,SAASC,KAAKmE,IACF,oBAAZA,EAAGoC,MACU,WAAZpC,EAAGoC,MAA2C,KAAtBpC,EAAGN,UAAU0C,YAG/BC,0BAAC,oHACuBA,0BAAC,qHAAYH,GAAYN,OAAO,+CAAhCS,sBACG,iBACzBP,MAAMC,QAAQO,KAAmBA,GAAoBA,MACrDpG,EAAK5B,cAAKJ,YAAUoI,IAAkBpI,eAExB8F,oCACfqC,0BAAC,qHAAYF,+CAAbE,mCACC1G,8CARF0G,OAWLC,EAAmBJ,GAAYN,OAAO,SAEV,IAArBU,IACJR,MAAMC,QAAQO,KAAmBA,GAAoBA,MACrDpG,EAAK5B,cAAKJ,YAAUoI,IAAkBpI,UAEvCyB,EAASqE,eAERrE,4CASU4G,qBACNnI,KAAKoE,iBAAgBlD,OAAO,SAACC,EAAMiH,OACtCC,EAAeD,EAAgBjH,eACN,IAAjBkH,EAA+BA,EAAelH,GAC3DgH,mCASIrG,EAAMC,OACPmD,EAAajD,OAAOkD,yBAAyBnF,KAAKoD,OAAQrB,GAC1DuG,GAAoBpD,KAAgB,WAAY,UAAU1B,WAAgB0B,EAAWxB,QACrF6E,EAAerD,QAA0C,IAArBA,EAAWxB,SACjD4E,MACGC,GAAgBzE,EAAK2C,gBAAgB3E,GAAO,KACzCU,EAAO,IAAIsB,EAAKhC,QACjBuE,eAAe7D,EAAMT,QACrBqB,OAAOrB,GAAOS,EAAKN,mBAEnBkB,OAAOrB,GAAOD,OAEZyG,GAAgBzE,EAAKyC,YAAYrB,EAAWxB,cAChDN,OAAOrB,GAAO/B,KAAKoD,OAAOrB,GAAZ,SAA6BG,OAAOJ,+CASvC0G,SACQ,mBAAfA,GAA2BxI,KAAKoE,eAAevD,IAAI2H,GACvDxI,4EAQMkD,kDACFnC,QAAQ,eACI,mBAAV0H,IACJtF,cAAcsF,QACd,GAA6B,oBAAzBjH,SAASC,KAAKgH,UAChBC,QAAQD,GAAO1H,QAAQ,yBAAEgB,OAAK4G,cAC3B5G,OACD,6BACI6G,EAAKC,mBAAmBF,OAC5B,yBACIC,EAAKE,eAAeH,OACxB,yBACIC,EAAKzF,cAAcwF,OACvB,wBACIC,EAAKG,YAAYJ,OACrB,sBACIC,EAAKI,YAAYL,iBAElB,IAAIM,MAAMC,UAGjB,CAAA,GAA6B,mBAAzB1H,SAASC,KAAKgH,SAKjB,IAAIQ,MAAMC,KAJVnI,QAAQ,SAAC4H,KACRzF,WAAWyF,QAMf3I,0CAODmJ,yDAAS,SACR,IAAIzB,MAAMyB,GAAQC,KAAK,IAAIlI,OAAO,SAACC,UACjCA,EAAKiC,OAAOuC,gBAClB3F,MAAMoD,wCAODiG,iBACsB,mBAA1B7H,SAASC,KAAK4H,GAA8B,eAEzCjG,QAAOkG,gBAAO,EAAGtJ,KAAKoD,OAAOmG,iBAAWF,SACV,oBAA1B7H,SAASC,KAAK4H,WAEpBX,QAAQW,GACRG,OAAO,oCAAmC,0BAC1CzI,QAAQ,yBAAEgB,OAAK2B,WACIzB,OAAOsF,KAAKkC,EAAKrG,QAAQI,SAASzB,GACpC,OAAO,KACF,qBAAV2B,gBAAAA,MACJN,OAAOrB,GAAZ,SAA6B2H,SAAShG,KAEjCN,OAAOrB,GAAO2B,WAIpB1D,KAAKoD,iDAOLpD,KAAK2J,UAAUC,aAAa,mCAS7BC,EAAMC,0BACPf,YAAY,sCAAIjI,6CACbiJ,EAAcjJ,EAAKQ,MAAM,GAAI,GACf,iBAATuI,IAAmBA,GAAQA,QAIjC,IAHCN,EAASM,EAAKN,OAChBS,GAAa,EACbC,GAAmB,EACdpC,EAAI,EAAGA,EAAI0B,EAAQ1B,IAAK,IAC3BgC,EAAKhC,KAAOkC,EAAYlC,GAAI,IACjB,QAGXA,IAAM0B,EAAS,GAAKQ,EAAYR,OAASA,OACxB,OAGJ,IAAfS,OACAtG,EAAQ5C,EAAKQ,OAAO,GAAI,GAAG,GAC3B2I,MACMC,EAAKC,IAAIN,GAAT,SAA2BO,cAE5B1G,EAAO5C,MAEXd,iCAOJ6J,UDnlBY,SAACQ,EAAQR,GACN,iBAATA,IAAmBA,GAAQA,YAClCS,EAAQ,EACNf,EAASM,EAAKN,OACF,OAAXc,GAAmBC,EAAQf,KACvBc,EAAO5G,EAAMoG,EAAKS,cAErBA,GAASA,IAAUf,EAAUc,OAAS3I,EC6kBrCyI,CAAInK,KAAKoD,OAAQyG,+CAMlBU,4DACe,IAAjBA,EAAMhB,QAAcvJ,KAAK8G,yBAAyB9G,KAAKoK,YAAaxD,KAAM,YACxE7F,QAAQ,YACP2G,MAAMC,QAAQkC,KAAOA,GAAQA,QAC5BnG,EAAQ8G,EAAKL,IAAIN,KAClB/C,kCAAyBpD,YAAUmG,KAAOjD,KAAM,wHAS9CgD,YAAAA,gBACHa,EAAQxI,OACXyG,QAAQ1I,KAAKoD,QACboG,OAAO,yBAAO9F,qBAAWkG,GAAgC,mBAAVlG,IAC/CxC,OAAO,SAACuJ,kBAAQ1I,OAAK2B,UAChBiB,QAAQQ,yBAAyBuF,EAAKtH,OAAQrB,GAAKoI,WAC9CM,KAEK,OAAV/G,GAAmC,qBAAVA,gBAAAA,KAAsBA,EAAA,SAAmB,KAC9DiH,EAASjH,EAAA,SAAkBiG,UAAUC,gBACrCjC,EAAmC,mBAAzBnG,SAASC,KAAKiC,KACxB3B,GAAO4F,EAAUD,MAAMkD,UACxBD,UACK1I,OAAOsF,KAAKoD,GAAQpB,UACzBoB,SAEC5I,GAAO2B,SAER+G,cAEP/C,MAAMC,QAAQ3H,KAAKoD,QACdsE,MAAMkD,UACRH,UACKzK,KAAKoD,OAAOmG,UAGjBkB,gEAQHzK,KAAK6K,OACA7K,KAAK6K,aAETA,aACG7K,KAAK2J,oBACD3J,WAEP+I,YAAY,sCAAIjI,6CACbiJ,EAAcjJ,EAAKQ,MAAM,GAAI,KACnBR,EAAKQ,OAAO,GAAI,GAAzBoC,YACHoH,EAAOpD,MAAMC,QAAQoD,EAAKF,OAAOC,kBAAYC,EAAKF,OAAOC,YAAYC,EAAKF,OAAOC,QAChFD,OAAOC,KAAOf,EAAY7I,OAAO,WAAkB2I,EAAM9H,OAAtBiJ,IAAAA,QAASC,IAAAA,KACzCC,EAASnJ,IAAQgI,EAAYR,OAAS,WACvCM,GAAQqB,EAASxH,EACpBgE,MAAMC,QAAQqD,EAAQnB,gBAAamB,EAAQnB,UAAamB,EAAQnB,IAE9DqB,EACKJ,QAGDG,EAAKpB,WACFmB,EAAQnB,WAGbiB,UACGC,EAAKF,OAAOC,SAEtB,GACI9K,KAAK6K,oDAQN1C,4DACAgD,EAAgBnL,KAAKoL,kBAAkBjD,GACvCO,EAAUzG,OAAOyG,QAAQyC,SAEE,mBAA/B3J,SAASC,KAAKzB,KAAKoD,SACc,mBAAjC5B,SAASC,KAAK0J,IACdA,EAAc5B,OAAS,IAGTxI,QAAQ,SAACe,EAAMC,KACtBsJ,QAAQvJ,EAAMC,KAEZ2G,EAAQa,OAAS,KAEvBxI,QAAQ,yBAAEgB,OAAKD,SACTuJ,QAAQvJ,EAAMC,UAGpBmC,gBAAiB,OACjBC,QAAQiD,SAAU,EAChBpH,KAAKoD,iDAlnBUtB,UACd,kBAAmB,kBAAkB0B,SAAShC,SAASC,KAAKK,wCA0DlDA,UAEP,OAATA,GACgB,qBAATA,gBAAAA,KACPA,EAAA,UACAA,EAAA,SAAiBsE,cAAgBtC,WCnJvC,IAAMwH,EAAoB,SAAC1F,OAAImE,mEACtB,gBACL,SAAiB5F,QAAQiD,SAAU,6BADjBtG,6CAEZS,EAASqE,EAAG2F,MAAMvL,KAAMc,eAC9B,SAAiBqD,QAAQiD,SAAU,OACnC,SAAiBvD,OAAOkG,GACjBxI,ICnBUiK,wFACEC,UACZA,EAAA,SAAiBC,oBAAoBZ,sCAG7BW,EAAM5B,UACd4B,EAAKjF,SAAS2D,IAAIN,kCAGZ4B,EAAM5B,EAAM8B,UAClBF,EAAKjF,SAASoF,OAAO/B,EAAM8B,oCAGnBF,UACRA,EAAKjF,SAAS4D,4CAGNqB,EAAMhB,UACdgB,EAAKjF,SAASkD,SAASe,YCb5BjI,EAAO,SAAC1C,UAAU,IAAIgE,EAAKhE,IAE/B+L,EAKEC,EALFD,aACAlC,EAIEmC,EAJFnC,SACAiC,EAGEE,EAHFF,OACAxB,EAEE0B,EAFF1B,SACAV,EACEoC,EADFpC,0GFXa,sCAAmB5I,4CACT,mBAAZA,EAAK,GAAmB,KAC1BiL,EAA0BjL,KAAfiJ,EAAejJ,kBAC1BwK,EAAkBS,EAAQhC,UAE1B,SAACxG,EAAQyE,EAAM9C,OAChBxB,EAAQwB,EAAWxB,eACZA,MAAQ4H,EAAkB5H,EAAO5C,GACrCoE,wBGRG8G,UACVA,EACK,sCAAuBlL,gDACrBkL,EAAKT,MAAMvL,KAAMc,IAGnB,SAACyC,EAAQyE,EAAM9C,OAChBU,EAAKV,EAAWxB,eACTA,MAAQ,sCAAuB5C,gDACjC8E,EAAG2F,MAAMvL,KAAMc,IAEjBoE"}